---
title: Finite resource pool
creation date: 2023-06-28 09:20 
status: todo
tags: 
- Development/ComputerBasic/DataStructure/Queue
- Sources/Courses/Algorithms
---

常见的有限资源池有线程池和数据库连接池。 CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。 **当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？** 线程池一般有两种处理策略：

- 非阻塞的处理方式，直接拒绝任务请求；
- 阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。

我们希望公平地处理每个排队的请求，先进者先服务，[[Sources/Courses/✍️ Algorithms/Queue|队列]] 这种数据结构很适合来存储排队请求。基于链表实现的队列，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。队列设置太大会导致等待的请求太多，设置太小会导致无法充分利用系统资源、发挥最大性能。 **对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。**