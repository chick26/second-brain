---
title: Array
creation date: 2022-03-01 09:26 
status: done
tags:
- Development/ComputerBasic/DataStructure/Array
- Sources/Courses/Algorithms
---
up:: [[• TOC for Algorithm Course]]

>数组是一种最基础的数据结构，在大部分编程语言中，数组都是从 0 开始编号的。

> [! Info]+ 线性表与非线性表
> 
> - **线性表**，数据最多只有前和后两个方向，包括**数组，链表、队列、栈**等。其中**数组** 是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
> - **非线性表**，数据之间并不是简单的前后关系，有二叉树、堆、图等


## 1 操作复杂度

### 1.1 查找操作

-   数组支持随机访问，根据下标随机访问的时间复杂度为 `O(1)`
-   排好序的数组用二分查找，时间复杂度是 `O(logn)`
-   顺序查找，最好时间复杂度为 `O(1)`，最差时间复杂度为 `O(n)`，平均时间复杂度为 `O(n)`

### 1.2 插入操作

假设数组的长度为 n，如果将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来给新来的数据，需要将第 k～n 这部分的元素都顺序地往后挪一位，共 ( n-k ) 次。

$$
\frac{\sum_{k=1}^n{n-k}}{n}=\frac{n}{2}=O(n)
$$


### 1.3 删除操作

如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。

## 2 数组的访问越界问题

C 语言中存在越界访问的问题, 如定义数组大小为 3 的数组 a,  a[3] 被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，其他高级语言一般会报角标越界异常。

Java 本身就会做越界检查，比如下面这几行 Java 代码，就会抛错

```java
// java. lang. ArrayIndexOutOfBoundsException
int[] a = new int[3];
a[3] = 10;
```

## 3 容器类

针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。

### 3.1 优势

- 封装多种数组操作的细节封装起来
- 支持动态扩容。扩容操作涉及内存申请和数据搬移，是比较耗时的。如果事先能确定需要存储的数据大小，最好**在创建 ArrayList 的时候事先指定数据大小**。

### 3.2 缺点

- Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。
- 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。
-  当要表示多维数组时，用数组往往会更加直观。比如 `Object[][] array`；而用容器的话则需要这样定义：`ArrayList<ArrayList> array`。

对于业务开发，直接使用容器就足够了，省时省力。但如果是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器。

>[!Question]- 为什么数组要从 0 开始编号?
>
>**为什么数组要从 0 开始编号，而不是从 1 开始呢？** 从 1 开始不是更符合人类的思维习惯吗？从数组存储的内存模型上来看，**“下标”最确切的定义应该是“偏移（offset）”**。
>
>- 从 0 开始编号，数组 a[k] 的内存寻址公式为:  `A[k]_address = base_address + k * type_sizec`
>- 从 1 开始编号，数组 a[k] 的内存寻址公式为:  `A[k]_address = base_address + (k-1)*type_sizec`
>
>对比两个公式，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。
>
>所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。另外，C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。当然，并不是所有语言的数组都是从 0 开始计数的，比如 Matlab。

## 4 JVM 垃圾回收与算法

一个对象如果没有任何与之关联的引用，即他们的引用计数为 0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。 为了解决引用计数法的循环引用问题，Java 使用了可达性分析，通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。

### 4.1 标记清除算法 (Mark-Sweep)

分为 **标注** 和 **清除** 两个阶段。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。

### 4.2 复制算法 (Copying)

为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法,按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。

### 4.3 标记整理算法 (Mark-Compact)

结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标记后不是清 理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。

>[!INFO]+ 分代收集
>
>根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代 (Tenured/Old Generation)和新生代 (Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。

### 4.4 新生代与复制算法

目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代 划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。

### 4.5 老年代与标记复制算法

而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。

- JAVA 虚拟机提到过的处于方法区的永生代 (Permanet Generation)，它用来存储 class 类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。
- 对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space (Survivor 目前存放对象的那一块)，少数情况会直接分配到老生代。
- 当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理。
- 如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。
- 在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。
- 当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被移到老生代中。
