---
title: 事务与锁
creation date: 2022-07-13 09:04 
status: done
tags:
- Sources/Courses/MySQL
- Development/Backend/Database/MySQL
---
up:: [[Sources/Courses/⚙️ Database/MySQL/• TOC for MySQL Course|• TOC for MySQL Course]]

## MySQL的事务

MySQL 支持三种不同的存储引擎：MyISAM 存储引擎、Memory 存储引擎和 InnoDB 存储引擎，但只有 InnoDB 存储引擎才支持事务。

### 什么是事务

- 由一组DML语句组成（insert、update、delete）
- 要么成功，要么执行不成功

### 事务的特征 ACID

- Atomicity：原子性 [undo log]

指事务中的所有 DML 操作，要么全部执行成功，要把全部执行失败，不会存在部分执行成功，另一部分执行失败的情况。事务在执行过程中发生错误，操作的数据会被回滚`Rollback`到事务开始前的状态，相当于事务没有执行过。


- Consistency：一致性

指事务在开始执行前和事务执行结束后，数据库中的数据完整性没有被破坏。数据应该从一个整个正确的状态，转换到另一个正确的状态，并且完全符合所有的预设规则，数据不会存在一个中间的状态。

- Isolation：隔离性

由于数据库支持并发操作，它允许多个客户端或者多个事务同时操作数据库中的数据。因此，数据库就必须要有一种方式来隔离不同的操作，防止个事务并发执行时由于交叉执行而导致数据的不一致，这就是事务的隔离性。

- Durability：持久性 [redo log]

指当事务成功结束后，即提交成功，事务对数据的修改就是永久的。数据不会因为系统出现故障而丢失。因此，为了实现事务的持久性，MySQL 与 Oracle 一样在提交事务时都是采用的预写日志的方式。即，提交事务时，先写日志，再写数据。只要日志成功写入，就是事务提交成功。

### 事务提交流程

`redo log`（重做日志）让`InnoDB`存储引擎拥有了崩溃恢复能力。  
`binlog`（归档日志）保证了`MySQL`集群架构的数据一致性。

![[Transaction Commit.excalidraw | 600](../../../../Extras/Excalidraw/%E6%95%B0%E6%8D%AE%E5%BA%93/Transaction%20Commit.excalidraw.md)

### 控制事务

- 开启事务：start transaction; begin
- 提交事务：commit、commit work（显式提交）
- 回滚事务：显式回滚 rollback  隐式回滚：客户端异常退出、宕机掉电等等
- 保存点（回滚点）：savepoint
- set设置事务隔离级别

### 事务的并发：隔离级别

- 读未提交：read-uncommited，会发生脏读
- 读提交：read-commited，避免脏读，不可以避免不可重复读，是Oracle默认的隔离级别
- 可重复读：repeatable-read，避免不可重复读，是MySQL默认的隔离级别
- 可序列化读：serializable

## 锁机制

MySQL 的不同存储引擎采用的锁机制不完全相同。`MyISAM` 存储引擎和 `Memory` 存储引擎 采用的表级锁。而 `InnoDB` 存储引擎既支持行级锁，也支持表级锁。但 `InnoDB` 默认采用的行级锁。

### 行锁

- 共享锁（S，读锁）

也叫作读锁。在同一个数据对象上可以有多把共享锁。如果一个事务在数据对象上加上了共享锁，则该事务可以读取数据但不能修改数据。其他的事务也可以在该数据对象上继续添加共享锁，也可以读取该数据，但同样也不能修改数据。

- 排它锁（X，写锁）

也叫作写锁。在同一个数据对象上只允许有一把排它锁，获取到数据排它锁的事务可以读取数据和修改数据。一旦数据被加上了排它锁，其他事务就不允许再对该数据添加任何类型的行锁。

### 表锁

- 意向共享锁（IS）

事务在给数据添加行级共享锁之前，必须先取得该表的意向共享锁。

- 意向排它锁（IX）

事务在给数据添加行级排他锁之前，必须先取得该表的意向排他锁。

### 死锁

死锁是指两个或两个以上事务在执行过程中，因互相的等待或者争抢锁资源而造成的互相等待的现象。

>[!Note]
>- 以固定的顺序访问表和行。比如对两个 job 批量更新的情形，简单方法是对 id 列表先排序，后执行，这样就避免了交叉等待锁的情形。
>- 大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。 
>- 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。 
>- 降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级 别从 RR 调整为 RC，可以避免掉很多因为 gap 锁造成的死锁。 
>- 为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁， 死锁的概率大大增大。


