<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sources on</title><link>chick26.github.io/sources/</link><description>Recent content in Sources on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="chick26.github.io/sources/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>chick26.github.io/Sources/Courses/-TOC-for-Courses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/-TOC-for-Courses/</guid><description>🌏 [[Sources MOC|Sources]] | [[Courses MOC|MOC]] | TOC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 for (let group of dv.</description></item><item><title/><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/-TOC-for-MySQL-Course/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/-TOC-for-MySQL-Course/</guid><description>🌏 [[• TOC for Courses]] | MySQL 1- [[MySQL数据库基础]] 2- [[InnoDB存储引擎]] 3- [[用户管理与访问控制]] 4- [[数据库对象]] 5- [[应用程序开发]] 6- [[事务与锁]] 7- [[备份与恢复]] 8- [[主从复制和主主复制]] 9- [[高可用架构]] 10- [[性能优化与运维管理]] 11- [[数据库的监控]] 12- [[数据库的中间件]]</description></item><item><title/><link>chick26.github.io/Sources/Courses/-Frontend-Interview/-TOC-for-Frontend-Interview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/-Frontend-Interview/-TOC-for-Frontend-Interview/</guid><description>🌏 [[Courses MOC]] | Frontend Interview TOC 1 2 3 4 5 table WITHOUT ID (&amp;#34;[[&amp;#34; + file.name + &amp;#34;]]&amp;#34;) as TITLE,dateformat(file.</description></item><item><title/><link>chick26.github.io/Sources/Sources-MOC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Sources-MOC/</guid><description>🌏 [[Atlases MOC|Atlases]] | Sources MOC [[Bookshelf|📚Bookshelf]] [!example]+ List your reading note
[[Courses MOC|🙋‍♀️ Courses]]</description></item><item><title/><link>chick26.github.io/Sources/Talks/-TOC-for-Talks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Talks/-TOC-for-Talks/</guid><description>🌏 [[Sources MOC]] | Untitled 1 2 3 4 5 6 7 table WITHOUT ID (&amp;#34;[[&amp;#34; + file.name + &amp;#34;]]&amp;#34;) as TITLE, string(map(file.</description></item><item><title>2022 前端生态趋势</title><link>chick26.github.io/Sources/Talks/%E5%B0%A4%E9%9B%A8%E6%BA%AA2022-%E5%89%8D%E7%AB%AF%E7%94%9F%E6%80%81%E8%B6%8B%E5%8A%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Talks/%E5%B0%A4%E9%9B%A8%E6%BA%AA2022-%E5%89%8D%E7%AB%AF%E7%94%9F%E6%80%81%E8%B6%8B%E5%8A%BF/</guid><description>开发范式&amp;amp;底层框架 React Hooks 受到 React Hooks 范式启发，多个框架分别推出了不同的范式：
Vue Composition API Svelte 3 SolidJS: 语法上跟 Hooks 语法更相似，但是实现上却跟 Vue Composition API 更相似的一个内在的实现 React Hooks 的开发体验问题 Hooks 执行原理和原生 JS 心智模型的差异 不能条件式调用 Stale Closure (过期闭包) 的心智负担 必须手动声明 useEffect 依赖 如何 &amp;ldquo;正确&amp;rdquo; 使用 useEffect 是个复杂的问题 需要 useMemo / useCallback 等手动优化 React 团队对改善开发体验的努力 useEvent RFC 改善 useCallback 的问题 useEffect 文档更新 React Forget 避免手动声明依赖 基于依赖追踪的范式重新得到重视 React Recoil Recoil 能创建一个数据流图（data-flow graph），从 atom（共享状态）到 selector（纯函数），再向下流向 React 组件。Atom 是组件可以订阅的状态单位。selector 可以同步或异步转换此状态</description></item><item><title>ACA-云计算基础</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Cloud-Tech/ACA-%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Cloud-Tech/ACA-%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/</guid><description>数据中心概述 理解、掌握数据中心的基础设施组成及现状
分类级别 国内 GB50174 一 2017 A 级，运行中断将造成将重大的损失、将造成公共场所秩序严过混乱 B 级，运行中断将造成将较大的经济损失、将造成公共场所秩序混乱 C 级，不属于 A 级或者 B 级的数据中心为 C 级 国际 TAL-942-B-2017 Tier 1 基级，基本基础设施，数据中心的只具有一组线，包括电力和互联网，连接系统的所有缺乏冗余的设备 （ 包括计算和存储 ） Tier 2 冗余设备级，冗余能力元件基础设施，具有冗余设备的数据中心的水平，但仍然是一组线连接到系统的所有设备 Tier 3 平行维护级别，同时维护的基础设施与设备的冗余数据中心的级别, 所有的计算机都有双电源和数据中心建筑结构按照合理的安装。此外 Tier3 数据中心的要求有几套动力配电线路系统来同时连接电脑设备 Tier 4 容错级，容错基础设施，数据中心水平多重、独立、相互冗余设备物理上分离，所有的电脑设备有双电源孬并根据数据中心建筑结构的合理安排 基础设施 基础设施：机房、装修、供电 （ 强电和 UPS ) 、散热、综合布线、安防、空调等相关设施 物理设施 ： 机柜、服务器、网络设备、网络安全设备、存储设备、灾备设备等 基础软件 ． 操作系统、数据库软件、防病毒软件等 管理支撑软件 ： 机房管理软件、集群管理软件、云平台软件、虚拟化软件等 传统数据中心现状 资源物理隔离 网络架构局限 传统三层架构，核心+汇聚+接入 [[STP]] 只能支持 50 个网络节点，且收敛时间长，不适宜云数据中心大规模组网 1 云计算关键技术 1.</description></item><item><title>Array</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Array/</guid><description>up:: [[• TOC for Algorithm Course]]
数组是一种最基础的数据结构，在大部分编程语言中，数组都是从 0 开始编号的。
[! Info]+ 线性表与非线性表
线性表，数据最多只有前和后两个方向，包括数组，链表、队列、栈等。其中数组 是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 非线性表，数据之间并不是简单的前后关系，有二叉树、堆、图等 1 操作复杂度 1.</description></item><item><title>Blocking queue</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Blocking-queue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Blocking-queue/</guid><description>问题 阻塞队列其实就是在 [[Queue|队列]] 基础上增加了阻塞操作。简单来说，就是
在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回； 如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。 使用阻塞队列，就可以轻松实现一个 生产者 - 消费者模型 这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。可以多配置几个“消费者”，来应对一个“生产者”
![[Blocking queue.excalidraw|800]]
实现 Python 基于阻塞队列实现的生产者 - 消费者模型：</description></item><item><title>Bracket Matching Using Stack</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Bracket-Matching-Using-Stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Bracket-Matching-Using-Stack/</guid><description>问题 假设表达式中只包含三种括号，圆括号 ()、方括号 [] 和花括号 {}，并且它们可以任意嵌套。
{[{}]} 或 [{()}([])] 等都为合法格式 {[}()] 或 [({)] 为不合法的格式 对于一个包含三种括号的表达式字符串，检查是否合法 ( 跟 ) 匹配，[ 跟 ] 匹配，{ 跟 } 匹配 思路 使用一个 [[Stack|栈]] 即可实现：</description></item><item><title>Browser forward and backward Using Stack</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Browser-forward-and-backward-Using-Stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Browser-forward-and-backward-Using-Stack/</guid><description>问题 依次访问完一串页面 a-b-c 之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面 b 和 a。后退到页面 a，点击前进按钮，就可以重新查看页面 b 和 c。但是，如果后退到页面 b 后，点击了新的页面 d，那就无法再通过前进、后退功能查看页面 c 了。
思路 使用两个 [[Stack|栈]] X 和 Y , 栈 X 中的栈顶数据表示当前访问的页面</description></item><item><title>Concurrent queue</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Concurrent-queue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Concurrent-queue/</guid><description>在多线程情况下，会有多个线程同时操作 [[Queue|队列]]，这个时候就会存在线程安全问题。线程安全的队列叫作并发队列。最简单直接的实现方式是直接在 enqueue ()、dequeue () 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</description></item><item><title>Expression evaluation Using Stack</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Expression-Evaluation-Using-Stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Expression-Evaluation-Using-Stack/</guid><description>问题 使用 [[Stack|栈]] 实现表达式求解
思路 需要两个 [[Stack|栈]] 来实现：一个栈保存操作数，另一个栈保存运算符。
从左向右遍历表达式，遇到数字就压入操作数栈； 遇到运算符，就与运算符栈的栈顶元素进行比较。 如果比运算符栈顶元素的优先级高，就将当前运算符压入栈； 如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</description></item><item><title>Finite resource pool</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Finite-resource-pool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Finite-resource-pool/</guid><description>常见的有限资源池有线程池和数据库连接池。 CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。 当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？ 线程池一般有两种处理策略：
非阻塞的处理方式，直接拒绝任务请求； 阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。 我们希望公平地处理每个排队的请求，先进者先服务，[[Queue|队列]] 这种数据结构很适合来存储排队请求。基于链表实现的队列，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。队列设置太大会导致等待的请求太多，设置太小会导致无法充分利用系统资源、发挥最大性能。 对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</description></item><item><title>Hash</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Hash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Hash/</guid><description/></item><item><title>Image Enhance Tools</title><link>chick26.github.io/Sources/Tools/Image-Enhance-Tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Tools/Image-Enhance-Tools/</guid><description>AI 照片修复 5 款 AI 老照片修复工具的横向比较 - 少数派
修复平台 工具 平台 价格 模型 CodeFormer 网页 免费（开源） Codebook Lookup TransFormer (CodeFormer), 2022 年 RestorePhotos.</description></item><item><title>InnoDB存储引擎</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid><description>up:: [[• TOC for Data Structure]]
InnoDB 存储引擎 有助于 Oracle、达梦、MongoDB
存储结构 数据库都是通过逻辑存储结构管理物理存储结构
物理存储结构：硬盘上的文件 数据文件 .ibd 文件和 ibdata 文件 这两种文件都是存放 Innodb 数据的文件，之所以有两种文件来存放 Innodb 的数据（包括索引），是因为 Innodb 的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是独享表空间存放存储数据。</description></item><item><title>Josephus Problem Using List</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Josephus-Problem-Using-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Josephus-Problem-Using-List/</guid><description>问题 有 n 个人围成一圈，顺序排号。从第一个人开始报数（从 1 到 m 报数），凡报到 m 的人退出圈子，直到船上仅剩 r 人为止, 问都有哪些编号的人下船了呢？
实现 假设 n=30，m=9，r=15 [[Array|数组]] 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 # -*- coding: utf-8 -*- __author__ = &amp;#39;xiaoxiaoming&amp;#39; n, m, r = 30, 9, 15 circle = list(range(1, n + 1)) # index+1代表当前报数的人在剩余报数人群中的编号 index = 0 result = [] while len(circle) &amp;gt; r: index += m-1 if (index &amp;gt;= len(circle)): index -= len(circle) result.</description></item><item><title>List</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/List/</guid><description>up:: [[• TOC for Algorithm Course]]
1 基本结构 ![[list-construct.excalidraw|600]]
1.1 单链表 上图中有两个特殊的结点，分别是第一个结点（头结点）和最后一个结点（尾结点）。 头结点用来记录链表的基地址，用它可以遍历得到整条链表。 尾结点指向一个空地址 NULL，表示这是链表上最后一个结点。 1.2 循环链表 和单链表相比，循环链表的优点是从链尾到链头比较方便。 当要处理的数据具有环型结构特点时，采用循环链表实现代码会简洁很多。 1.</description></item><item><title>LRU Using List</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/LRU-Using-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/LRU-Using-List/</guid><description>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。
[!INFO]- 缓存淘汰策略
先进先出策略 FIFO（First In，First Out） 最少使用策略 LFU（Least Frequently Used） 最近最少使用策略 LRU（Least Recently Used） LRU 缓存的实现 思路：维护一个[[List|有序单链表]]，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表：</description></item><item><title>Mac Setup</title><link>chick26.github.io/Sources/Tools/Mac-Setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Tools/Mac-Setup/</guid><description>System Preferences Dock Remove most applications from Dock Smaller Dock Automatic Hide Track pad Tap to Click Point &amp;amp; Click -&amp;gt; Look up &amp;amp; data detectors off System Preferences (Terminal) Override more system preferences from the terminal &amp;hellip;</description></item><item><title>MySQL数据库基础</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</guid><description>up:: [[• TOC for Data Structure]]
虚拟机使用说明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [root@mysql8 ~]# tree tools/ tools/ ├── backup 备份和恢复工具 │ ├── binlog2sql.</description></item><item><title>Palindromic string</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Palindromic-string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Palindromic-string/</guid><description>问题 如果字符串是通过 [[List| 单链表]] 来存储的，那该如何来判断是一个回文串呢？
思路 使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。这样当快指针指向末尾时，慢指针指向了中点。 在慢指针前进的过程中，同时修改其 next 指针指向上一个元素 prev，使得链表前半部分反序。 最后比较中点两侧的链表是否相等。 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class ListNode(object): def __init__(self, val, next=None): self.</description></item><item><title>Queue</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Queue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Queue/</guid><description>up:: [[• TOC for Algorithm Course]]
1 基本结构 [!Example]- 操作受限，先进先出 循环队列、阻塞队列、并发队列等具有某些额外特性的队列，它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列； Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。
2 队列的实现 用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。</description></item><item><title>Recursion</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Recursion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Recursion/</guid><description>up:: [[• TOC for Algorithm Course]]
[! Question]+ 如何理解“递归”？
递归是一种非常高效、简洁的编码技巧，编写递归代码的关键是写出递推公式，找出终止条件，然后再翻译成递归代码; 递归代码虽然简洁高效，但是，递归代码有很多副作用。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等; 很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等. 递归需要满足的三个条件 满足三个条件的问题可以用递归来解决： 1.</description></item><item><title>Redis 基础</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/Redis/01-Redis-%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/Redis/01-Redis-%E5%9F%BA%E7%A1%80/</guid><description>简介 Redis 是一个高性能的 key-value 数据库
Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis 不仅仅支持简单的 Key-Value 类型的数据，同时还提供 list, set, zset, hash等数据结构的存储。 Redis 支持数据的备份，即 Master-Slave 模式的数据备份 优势 Redis 是基于内存的数据库，不论读写操作都是在内存上完成的，完全吊打磁盘数据 库的速度。Redis 之所以可以使用单线程来处理，其中的一个原因是，内存操作对资源损耗较小，保证了处理的高效性。</description></item><item><title>Redis 高级特性</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/Redis/02-Redis-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/Redis/02-Redis-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</guid><description>数据的持久化 RDB 默认，本质就是快照。每隔一段时间将内存中的数据写到文件上。
1 2 3 # save 3600 1 在1个小时内，如果有1个值发生了变化，就执行RDB # save 300 100 在5分钟内，如果有100个值发生了变化，就执行RDB # save 60 10000 在1分钟内，如果有1w个值发生了变化，就执行RDB 缺点：在两次RDB之间数据可能发生丢失。 优点：恢复的速度很快 AOF append only file 日志，默认关闭</description></item><item><title>Stack</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Stack/</guid><description>up:: [[• TOC for Algorithm Course]]
1 基本结构 [!Example]- 操作受限, 后进先出, 先进后出
从功能上来说，数组或链表可以替代栈，但特定的数据结构是对特定场景的抽象，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。
当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，就应该首选“栈”这种数据结构。
2 代码实现 栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。
2.1 java 数组实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 基于数组实现的顺序栈 public class ArrayStack { private String[] items; // 数组 private int count; // 栈中元素个数 private int n; // 栈的大小 // 初始化数组，申请一个大小为 n 的数组空间 public ArrayStack(int n) { this.</description></item><item><title>The Time Value of Money</title><link>chick26.github.io/Sources/Courses/-CFA/The-Time-Value-of-Money/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/-CFA/The-Time-Value-of-Money/</guid><description>interest rates 利率 required rates of return 要求回报率 discount rates 贴现率 real risk-free rate 无风险真实利率 the effective annual rate 实际年利率 ordinary annuity 普通年金 annuity due 到期年金 perpetuity 永续年金 INTEREST RATE 利率 &amp;gt; 0 Money available at the present time is worth more than the same amount in the future due to its potential earning capacity.</description></item><item><title>• TOC for Algorithm Course</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/-TOC-for-Algorithm-Course/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/-TOC-for-Algorithm-Course/</guid><description>🌏 [[• TOC for Courses]] | Algorithm Data structure 01- [[Array|数组]] 02- [[List|链表]] 03- [[Stack|栈]] 04- [[Queue|队列]] 05- [[Recursion|递归]]</description></item><item><title>主从复制和主主复制</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8C%E4%B8%BB%E4%B8%BB%E5%A4%8D%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8C%E4%B8%BB%E4%B8%BB%E5%A4%8D%E5%88%B6/</guid><description>up:: [[• TOC for Data Structure]]
主从复制 主从复制（也称 AB 复制）允许将来自一个 MySQL 数据库服务器（主服务器）的数据复制到一个或多个 MySQL 数据库服务器（从服务器）。根据参数文件的配置，可以复制数据库中的所有数据库，所选数据库甚至选定的表。
主从复制的原理 ![[Master Slave Replication.excalidraw | 600]]</description></item><item><title>事务与锁</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81/</guid><description>up:: [[• TOC for Data Structure]]
MySQL的事务 MySQL 支持三种不同的存储引擎：MyISAM 存储引擎、Memory 存储引擎和 InnoDB 存储引擎，但只有 InnoDB 存储引擎才支持事务。
什么是事务 由一组DML语句组成（insert、update、delete） 要么成功，要么执行不成功 事务的特征 ACID Atomicity：原子性 [undo log] 指事务中的所有 DML 操作，要么全部执行成功，要把全部执行失败，不会存在部分执行成功，另一部分执行失败的情况。事务在执行过程中发生错误，操作的数据会被回滚Rollback到事务开始前的状态，相当于事务没有执行过。</description></item><item><title>云计算架构</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Cloud-Tech/%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Cloud-Tech/%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84/</guid><description/></item><item><title>前端技术应用方向</title><link>chick26.github.io/Sources/Talks/%E9%98%BF%E9%87%8C%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%E7%94%9F/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8%E6%96%B9%E5%90%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Talks/%E9%98%BF%E9%87%8C%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%E7%94%9F/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8%E6%96%B9%E5%90%91/</guid><description>技术应用方向 互动技术 动画: cSS3 | SVG | Lottie | Canvas 3D: WebGL | oasis 3D | lottie-pixi WebXR: 结合 AR | VR 智能化 图像大厨 imgcook Node.</description></item><item><title>图片懒加载</title><link>chick26.github.io/Sources/Courses/-Frontend-Interview/%E9%97%AE%E7%AD%94%E6%B1%87%E6%80%BB/Q0001-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/-Frontend-Interview/%E9%97%AE%E7%AD%94%E6%B1%87%E6%80%BB/Q0001-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</guid><description>问题 网站开发中，如何实现图片的懒加载，随着 web 技术的发展，他有没有一些更好的方案
解析 懒加载，顾名思义，在当前网页，滑动页面到能看到图片的时候再加载图片，故问题拆分成两个：
如何判断图片出现在了当前视口 （即如何判断我们能够看到图片） 如何控制图片的加载 解答 ![[Lazyload Img.excalidraw | 650]]
1. 位置计算 + 滚动事件 (Scroll) + DataSet API 实现 图片懒加载_窗口高度</description></item><item><title>备份与恢复</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</guid><description>up:: [[• TOC for Data Structure]]
基本的术语 备份与恢复方式 MySQL 的备份方法可以根据不同的方式进行划分。例如，根据备份的方法可以划分为物理备份和逻辑备份；根据备份手段、备份的数据范围及备份时数据服务是否在线等来划分，如: 根据备份的数据集的范围可以划分为全量备份、增量备份和差异备份；根据备份时数据服务是否在线可以划分为热备份和冷备份。
逻辑备份：表中的数据 物理备份：备份时直接复制备份这些数据库的文件 冷备份：一致性备份、脱机备份（需要停机） 热备份：不一致性备份、联机备份（不需要停机） 全量备份：备份数据库结构和文件结构 增量备份：仅备份自上一次完全备份或增量备份之后所增加的数据内容 工具使用 Mydumper 热备份 mydumper，MySQL 在备份方面包含了自身的 mysqldump 工具，但其只支持单线程工作，这就使得它无法迅速的备份数据。而 mydumper 作为一个实用工具，能够良好支持多线程工作，这使得它在处理速度方面十倍于传统的 mysqldump。</description></item><item><title>应用程序开发</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</guid><description>up:: [[• TOC for Data Structure]]
存储过程 procedure 打印Hello World 1 2 3 4 5 6 7 8 9 10 set@result=&amp;#34;&amp;#34;;delimiter$$createproceduresayHelloWorld()beginselect&amp;#34;Hello World&amp;#34;into@result;end$$delimiter; 基于员工表（emp）, 创建存储过程raiseSalaryByEmpno，为指定的员工涨10%的工资，并输出涨前和涨后的薪水。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 set@beforeRaise=0;set@afterRaise=0;delimiter$$createprocedureraiseSalaryByEmpno(inenoint)begin-- 查询员工涨前的薪水 selectsalinto@beforeRaisefromempwhereempno=eno;-- 给员工涨工资 updateempsetsal=sal*1.</description></item><item><title>性能优化与运维管理</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86/</guid><description>up:: [[• TOC for Data Structure]]
MySQL 的性能优化需要以基准测试为基础，并且主要针对查询语句进行性能分析。在分析的过程中可以借助一系列工具来针对 SQL 的执行计划和资源消费的情况，并最终给出 SQL 的建议指导。
基准测试 baseline MySQL 数据库基准测试时的关键指标包括以下 3 个方面：
TPS/QPS：衡量吞吐量 响应时间：包括平均响应时间、最小响应时间、最大响应时间、时间百分比等， 其中时间百分比参考意义较大，如前 95%的请求的最大响应时间 并发量：同时处理的查询请求的数量 Sysbench 使用 sysbench 测试服务器的CPU性能　 1 sysbench cpu --cpu-max-prime=20000 --threads=2 run 使用 sysbench 测试磁盘的 IOPS，执行下面的语句。　 1 2 3 4 5 6 7 8 9 10 11 # 准备测试数据 sysbench fileio --file-total-size=1G --file-test-mode=rndrw \ --time=30 --max-requests=0 prepare # 开始测试 sysbench fileio --file-total-size=1G --file-test-mode=rndrw \ --time=30 --max-requests=0 run # 清除测试数据 sysbench fileio --file-total-size=1G --file-test-mode=rndrw \ --time=30 --max-requests=0 cleanup 分析查询语句的性能 Explain 在 MySQL 中通过 explain 命令获取 MySQL 如何执行查询语句的信息，包括在查询语句执行过程中表如何连接和连接的顺序 (SQL的执行的过程)</description></item><item><title>数据库对象</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1/</guid><description>up:: [[• TOC for Data Structure]]
表 数据类型 数值类型 MySQL 支持所有标准 SQL 数值数据类型。这些类型包括严格数值数据类型(INTEGER、 SMALLINT、DECIMAL 和 NUMERIC)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)
日期和时间类型 表示时间值的日期和时间类型为 DATETIME、DATE、TIMESTAMP、TIME 和 YEAR</description></item><item><title>数据库的中间件</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6/</guid><description>up:: [[• TOC for Data Structure]]
MySQL 数据库使用过程中会通过搭建主从复制的架构来提高性能，同时采用分库分表的模式来解决读写分离的问题。MySQL 数据库的中间件就是为了更好地使 MySQL 支持这些应用的场景。主流的 MySQL 数据库中间件有 ProxySQL、 Mycat、Atlas 和 Cobar 等等。
引入了数据库中间件以后，客户端就不直接操作操作 MySQL 数据库集群，而是通过数据库中间件进行操作。</description></item><item><title>数据库的监控</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%9B%91%E6%8E%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%9B%91%E6%8E%A7/</guid><description>up:: [[• TOC for Data Structure]]
监控指标 可用性指标 是否可以通过网络连接 1 mysqladmin -uroot -p ping 数据库的最大连接数 1 2 3 4 5 6 7 showvariableslike&amp;#39;max_connections&amp;#39;;+-----------------+-------+|Variable_name|Value|+-----------------+-------+|max_connections|151|+-----------------+-------+ 当前 MySQL 打开的连接数 1 2 3 4 5 6 7 showglobalstatuslike&amp;#39;Threads_connected&amp;#39;;+-------------------+-------+|Variable_name|Value|+-------------------+-------+|Threads_connected|1|+-------------------+-------+ 性能指标 指标名称 指标说明 QPS MySQL 每秒处理的请求数量 TPS MySQL 每秒处理的事务数量 并发数 MySQL 实例当前并行处理的会话数量 连接数 连接到 MySQL 数据库会话的数量 缓存命中率 查询命中缓存的百分比 [!</description></item><item><title>浏览器中如何实现剪切板复制内容的功能</title><link>chick26.github.io/Sources/Courses/-Frontend-Interview/%E9%97%AE%E7%AD%94%E6%B1%87%E6%80%BB/Q0002-%E5%89%AA%E5%88%87%E6%9D%BF%E5%A4%8D%E5%88%B6%E5%86%85%E5%AE%B9%E7%9A%84%E5%8A%9F%E8%83%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/-Frontend-Interview/%E9%97%AE%E7%AD%94%E6%B1%87%E6%80%BB/Q0002-%E5%89%AA%E5%88%87%E6%9D%BF%E5%A4%8D%E5%88%B6%E5%86%85%E5%AE%B9%E7%9A%84%E5%8A%9F%E8%83%BD/</guid><description>问题 在一些博客系统，如掘金的博客中，可以复制代码，它是如何实现的
解答 第三方库 clipboard-copy  Clipboard API 1 navigator.clipboard.writeText(text); Selection API + execCommand 选中 Selection API 1 2 3 4 5 6 7 8 9 10 11 12 13 const selection = window.</description></item><item><title>用户管理与访问控制</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</guid><description>up:: [[• TOC for Data Structure]]
用户的管理 系统表：mysql.user
1 2 3 4 5 6 7 8 9 10 11 mysql&amp;gt; select user from mysql.</description></item><item><title>计算机网络</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Communicate-Tech/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Communicate-Tech/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid><description>定义</description></item><item><title>高可用架构</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Database/MySQL/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/</guid><description>up:: [[• TOC for Data Structure]]
MySQL 的主从复制是一种主从式的架构。由于整个架构中只存在一个主节点 master，当它发了宕机或者出现问题的时候势 必影响整个集群的正常工作。因此需要基于高可用的架构来解决 MySQL 主从复制的单点故障问题。
高可用架构的核心就是对主节点 master 进行监控，当其出现故障的时候通过提升某一从节点为新的主节点，从而实现故障的自动转移。
MHA MHA (Master HA) 能够在 30 秒内实 现故障切换，并能在故障切换中，最大可能的保证数据一致性。MHA 主备切换的过程如下：</description></item></channel></rss>