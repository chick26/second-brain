<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sources/Courses/Algorithms on </title>
    <link>chick26.github.io/tags/Sources/Courses/Algorithms/</link>
    <description>Recent content in Sources/Courses/Algorithms on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="chick26.github.io/tags/Sources/Courses/Algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Array</title>
      <link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Array/</guid>
      <description>up:: [ • TOC for Algorithm Course
 数组是一种最基础的数据结构，在大部分编程语言中，数组都是从 0 开始编号的。
  [! Info]+ 线性表与非线性表
 线性表，数据最多只有前和后两个方向，包括数组，链表、队列、栈等。其中数组 是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 非线性表，数据之间并不是简单的前后关系，有二叉树、堆、图等   1 操作复杂度 1.</description>
    </item>
    
    <item>
      <title>Blocking queue</title>
      <link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Blocking-queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Blocking-queue/</guid>
      <description>问题 阻塞队列其实就是在 [[Queue.md|队列]] 基础上增加了阻塞操作。简单来说，就是
 在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回； 如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。  使用阻塞队列，就可以轻松实现一个 生产者 - 消费者模型 这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。可以多配置几个“消费者”，来应对一个“生产者”
![ Blocking queue.excalidraw|800
实现 Python 基于阻塞队列实现的生产者 - 消费者模型：</description>
    </item>
    
    <item>
      <title>Bracket Matching Using Stack</title>
      <link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Bracket-Matching-Using-Stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Bracket-Matching-Using-Stack/</guid>
      <description>问题 假设表达式中只包含三种括号，圆括号 ()、方括号 [] 和花括号 {}，并且它们可以任意嵌套。
 {[{}]} 或 [{()}([])] 等都为合法格式 {[}()] 或 [({)] 为不合法的格式 对于一个包含三种括号的表达式字符串，检查是否合法 ( 跟 ) 匹配，[ 跟 ] 匹配，{ 跟 } 匹配  思路 使用一个 [[Stack.</description>
    </item>
    
    <item>
      <title>Browser forward and backward Using Stack</title>
      <link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Browser-forward-and-backward-Using-Stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Browser-forward-and-backward-Using-Stack/</guid>
      <description>问题 依次访问完一串页面 a-b-c 之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面 b 和 a。后退到页面 a，点击前进按钮，就可以重新查看页面 b 和 c。但是，如果后退到页面 b 后，点击了新的页面 d，那就无法再通过前进、后退功能查看页面 c 了。
思路 使用两个 [[Stack.md|栈]] X 和 Y , 栈 X 中的栈顶数据表示当前访问的页面</description>
    </item>
    
    <item>
      <title>Concurrent queue</title>
      <link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Concurrent-queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Concurrent-queue/</guid>
      <description>在多线程情况下，会有多个线程同时操作 [[Queue.md|队列]]，这个时候就会存在线程安全问题。线程安全的队列叫作并发队列。最简单直接的实现方式是直接在 enqueue ()、dequeue () 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</description>
    </item>
    
    <item>
      <title>Expression evaluation Using Stack</title>
      <link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Expression-Evaluation-Using-Stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Expression-Evaluation-Using-Stack/</guid>
      <description>问题 使用 [[Stack.md|栈]] 实现表达式求解
思路 需要两个 [[Stack.md|栈]] 来实现：一个栈保存操作数，另一个栈保存运算符。
 从左向右遍历表达式，遇到数字就压入操作数栈； 遇到运算符，就与运算符栈的栈顶元素进行比较。  如果比运算符栈顶元素的优先级高，就将当前运算符压入栈； 如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。    </description>
    </item>
    
    <item>
      <title>Finite resource pool</title>
      <link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Finite-resource-pool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Finite-resource-pool/</guid>
      <description>常见的有限资源池有线程池和数据库连接池。 CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。 当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？ 线程池一般有两种处理策略：
 非阻塞的处理方式，直接拒绝任务请求； 阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。  我们希望公平地处理每个排队的请求，先进者先服务，[[Queue.md|队列]] 这种数据结构很适合来存储排队请求。基于链表实现的队列，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。队列设置太大会导致等待的请求太多，设置太小会导致无法充分利用系统资源、发挥最大性能。 对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</description>
    </item>
    
    <item>
      <title>Hash</title>
      <link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Hash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Hash/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Josephus Problem Using List</title>
      <link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Josephus-Problem-Using-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Josephus-Problem-Using-List/</guid>
      <description>问题 有 n 个人围成一圈，顺序排号。从第一个人开始报数（从 1 到 m 报数），凡报到 m 的人退出圈子，直到船上仅剩 r 人为止, 问都有哪些编号的人下船了呢？
实现  假设 n=30，m=9，r=15 [[Array.md|数组]] 实现  1 2 3 4 5 6 7 8 9 10 11 12 13  # -*- coding: utf-8 -*- __author__ = &amp;#39;xiaoxiaoming&amp;#39; n, m, r = 30, 9, 15 circle = list(range(1, n + 1)) # index+1代表当前报数的人在剩余报数人群中的编号 index = 0 result = [] while len(circle) &amp;gt; r: index += m-1 if (index &amp;gt;= len(circle)): index -= len(circle) result.</description>
    </item>
    
    <item>
      <title>List</title>
      <link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/List/</guid>
      <description>up:: [ • TOC for Algorithm Course
1 基本结构 ![[../../../Extras/Excalidraw/算法之美/list-construct.excalidraw.md|600]]
1.1 单链表  上图中有两个特殊的结点，分别是第一个结点（头结点）和最后一个结点（尾结点）。 头结点用来记录链表的基地址，用它可以遍历得到整条链表。 尾结点指向一个空地址 NULL，表示这是链表上最后一个结点。  1.2 循环链表  和单链表相比，循环链表的优点是从链尾到链头比较方便。 当要处理的数据具有环型结构特点时，采用循环链表实现代码会简洁很多。  1.</description>
    </item>
    
    <item>
      <title>LRU Using List</title>
      <link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/LRU-Using-List/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/LRU-Using-List/</guid>
      <description>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。
 [!INFO]- 缓存淘汰策略
 先进先出策略 FIFO（First In，First Out） 最少使用策略 LFU（Least Frequently Used） 最近最少使用策略 LRU（Least Recently Used）   LRU 缓存的实现 思路：维护一个[[List.</description>
    </item>
    
    <item>
      <title>Palindromic string</title>
      <link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Palindromic-string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Palindromic-string/</guid>
      <description>问题 如果字符串是通过 [[List.md| 单链表]] 来存储的，那该如何来判断是一个回文串呢？
思路  使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。这样当快指针指向末尾时，慢指针指向了中点。 在慢指针前进的过程中，同时修改其 next 指针指向上一个元素 prev，使得链表前半部分反序。 最后比较中点两侧的链表是否相等。  实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  class ListNode(object): def __init__(self, val, next=None): self.</description>
    </item>
    
    <item>
      <title>Queue</title>
      <link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Queue/</guid>
      <description>up:: [ • TOC for Algorithm Course
1 基本结构  [!Example]- 操作受限，先进先出 循环队列、阻塞队列、并发队列等具有某些额外特性的队列，它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列； Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。</description>
    </item>
    
    <item>
      <title>Recursion</title>
      <link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Recursion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Recursion/</guid>
      <description>up:: [ • TOC for Algorithm Course
 [! Question]+ 如何理解“递归”？
 递归是一种非常高效、简洁的编码技巧，编写递归代码的关键是写出递推公式，找出终止条件，然后再翻译成递归代码; 递归代码虽然简洁高效，但是，递归代码有很多副作用。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等; 很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等.   递归需要满足的三个条件 满足三个条件的问题可以用递归来解决： 1.</description>
    </item>
    
    <item>
      <title>Stack</title>
      <link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Stack/</guid>
      <description>up:: [ • TOC for Algorithm Course
1 基本结构  [!Example]- 操作受限, 后进先出, 先进后出
从功能上来说，数组或链表可以替代栈，但特定的数据结构是对特定场景的抽象，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。
当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，就应该首选“栈”这种数据结构。
 2 代码实现 栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。</description>
    </item>
    
  </channel>
</rss>
