<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development/Frontend on </title>
    <link>chick26.github.io/tags/development/frontend/</link>
    <description>Recent content in Development/Frontend on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="chick26.github.io/tags/development/frontend/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2022 前端生态趋势</title>
      <link>chick26.github.io/sources/talks/%E5%B0%A4%E9%9B%A8%E6%BA%AA2022-%E5%89%8D%E7%AB%AF%E7%94%9F%E6%80%81%E8%B6%8B%E5%8A%BF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/sources/talks/%E5%B0%A4%E9%9B%A8%E6%BA%AA2022-%E5%89%8D%E7%AB%AF%E7%94%9F%E6%80%81%E8%B6%8B%E5%8A%BF/</guid>
      <description>开发范式&amp;amp;底层框架 React Hooks 受到 React Hooks 范式启发，多个框架分别推出了不同的范式：
 Vue Composition API Svelte 3 SolidJS: 语法上跟 Hooks 语法更相似，但是实现上却跟 Vue Composition API 更相似的一个内在的实现  React Hooks 的开发体验问题  Hooks 执行原理和原生 JS 心智模型的差异 不能条件式调用 Stale Closure (过期闭包) 的心智负担 必须手动声明 useEffect 依赖 如何 &amp;ldquo;正确&amp;rdquo; 使用 useEffect 是个复杂的问题 需要 useMemo / useCallback 等手动优化  React 团队对改善开发体验的努力  useEvent RFC 改善 useCallback 的问题 useEffect 文档更新 React Forget 避免手动声明依赖  基于依赖追踪的范式重新得到重视 React Recoil  Recoil 能创建一个数据流图（data-flow graph），从 atom（共享状态）到 selector（纯函数），再向下流向 React 组件。Atom 是组件可以订阅的状态单位。selector 可以同步或异步转换此状态</description>
    </item>
    
    <item>
      <title>2022 前端生态趋势</title>
      <link>chick26.github.io/sources/talks/%E5%B0%A4%E9%9B%A8%E6%BA%AA2022-%E5%89%8D%E7%AB%AF%E7%94%9F%E6%80%81%E8%B6%8B%E5%8A%BF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/sources/talks/%E5%B0%A4%E9%9B%A8%E6%BA%AA2022-%E5%89%8D%E7%AB%AF%E7%94%9F%E6%80%81%E8%B6%8B%E5%8A%BF/</guid>
      <description>开发范式&amp;amp;底层框架 React Hooks 受到 React Hooks 范式启发，多个框架分别推出了不同的范式：
 Vue Composition API Svelte 3 SolidJS: 语法上跟 Hooks 语法更相似，但是实现上却跟 Vue Composition API 更相似的一个内在的实现  React Hooks 的开发体验问题  Hooks 执行原理和原生 JS 心智模型的差异 不能条件式调用 Stale Closure (过期闭包) 的心智负担 必须手动声明 useEffect 依赖 如何 &amp;ldquo;正确&amp;rdquo; 使用 useEffect 是个复杂的问题 需要 useMemo / useCallback 等手动优化  React 团队对改善开发体验的努力  useEvent RFC 改善 useCallback 的问题 useEffect 文档更新 React Forget 避免手动声明依赖  基于依赖追踪的范式重新得到重视 React Recoil  Recoil 能创建一个数据流图（data-flow graph），从 atom（共享状态）到 selector（纯函数），再向下流向 React 组件。Atom 是组件可以订阅的状态单位。selector 可以同步或异步转换此状态</description>
    </item>
    
    <item>
      <title>Document Handler</title>
      <link>chick26.github.io/cards/-front-dev/tool/document-handler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/tool/document-handler/</guid>
      <description>up:: [ • TOC for Frontend
1. PDF PDF.js  Github: mozilla/pdf.js: PDF Reader in JavaScript Document: PDF.js  PDF.js 是使用 HTML5 构建的可移植文档格式 (PDF) 查看器。它由社区驱动并受 Mozilla 支持，目标是创建一个通用的、基于 Web 标准的平台来解析和呈现 PDF。</description>
    </item>
    
    <item>
      <title>dumi 组件库搭建</title>
      <link>chick26.github.io/cards/-front-dev/uilibrary/dumi-%E7%BB%84%E4%BB%B6%E5%BA%93%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/uilibrary/dumi-%E7%BB%84%E4%BB%B6%E5%BA%93%E6%90%AD%E5%BB%BA/</guid>
      <description>up:: [ • TOC for Frontend
配置相关 father 打包  esm 和 cjs 支持 rollup 和 babel 两种打包方式，rollup 和 babel 两者的区别在于：</description>
    </item>
    
    <item>
      <title>dumi 组件库搭建</title>
      <link>chick26.github.io/cards/-front-dev/uilibrary/dumi-%E7%BB%84%E4%BB%B6%E5%BA%93%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/uilibrary/dumi-%E7%BB%84%E4%BB%B6%E5%BA%93%E6%90%AD%E5%BB%BA/</guid>
      <description>up:: [ • TOC for Frontend
配置相关 father 打包  esm 和 cjs 支持 rollup 和 babel 两种打包方式，rollup 和 babel 两者的区别在于：</description>
    </item>
    
    <item>
      <title>File Preview In Javascript</title>
      <link>chick26.github.io/cards/-front-dev/tool/file-preview-in-javascript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/tool/file-preview-in-javascript/</guid>
      <description>up:: [ • TOC for Frontend
实现方案    文档格式 老的开源组件 替代开源组件     word（docx） mammoth docx-preview(npm)   powerpoint（pptx） pptxjs pptxjs改造开发   excel（xlsx） sheetjs、handsontable exceljs(npm)、handsontable(npm)(npm)   pdf（pdf） pdfjs pdfjs(npm)   图片 jquery.</description>
    </item>
    
    <item>
      <title>HTML</title>
      <link>chick26.github.io/cards/-front-dev/html/html/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/html/html/</guid>
      <description>up:: [ • TOC for Frontend
Head  注意: [[HTML-HEAD.md|HEAD列表]]中 找到HTML文档&amp;lt;head&amp;gt;标签内所有可配置的属性。
 Meta 标签 Doctype（文档类型） 以下Doctype标签声明文档为HTML5类型，需要写在HTML文件的顶部。
1 2  &amp;lt;!-- 声明文档为 HTML5 类型 --&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>HTML-HEAD</title>
      <link>chick26.github.io/cards/-front-dev/html/html-head/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/html/html-head/</guid>
      <description>up:: [ • TOC for Frontend
🤯 HEAD  HTML &amp;lt;head&amp;gt; 元素的简单指南
 最小推荐 以下是构成任何 Web 页面（网站/应用程序）的基本要素：
1 2 3 4 5 6 7  &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1&amp;#34;&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>HTML-HEAD</title>
      <link>chick26.github.io/cards/-front-dev/html/html-head/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/html/html-head/</guid>
      <description>up:: [ • TOC for Frontend
🤯 HEAD  HTML &amp;lt;head&amp;gt; 元素的简单指南
 最小推荐 以下是构成任何 Web 页面（网站/应用程序）的基本要素：
1 2 3 4 5 6 7  &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1&amp;#34;&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>HTML-Principel</title>
      <link>chick26.github.io/cards/-front-dev/html/html-principel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/html/html-principel/</guid>
      <description>up:: [ • TOC for Frontend
HTML 最佳实践 编写易于维护与扩展的 HTML 文档。
全局 以 DOCTYPE 为开头 激活标准模式需要 DOCTYPE。
Bad:
1 2 3  &amp;lt;html&amp;gt; .</description>
    </item>
    
    <item>
      <title>HTML-Semantic</title>
      <link>chick26.github.io/cards/-front-dev/html/html-semantic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/html/html-semantic/</guid>
      <description>up:: [ • TOC for Frontend
什么是语义元素？ 非语义元素的例子：&amp;lt;div&amp;gt;和&amp;lt;span&amp;gt;- 没有说明它的内容。 语义元素示例： &amp;lt;form&amp;gt;、&amp;lt;table&amp;gt;和&amp;lt;article&amp;gt;- 明确定义其内容。
HTML 中的语义元素 许多网站包含 HTML 代码，例如： 来指示导航、页眉和页脚。
在 HTML 中，有一些语义元素可用于定义网页的不同部分：</description>
    </item>
    
    <item>
      <title>HTML-Semantic</title>
      <link>chick26.github.io/cards/-front-dev/html/html-semantic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/html/html-semantic/</guid>
      <description>up:: [ • TOC for Frontend
什么是语义元素？ 非语义元素的例子：&amp;lt;div&amp;gt;和&amp;lt;span&amp;gt;- 没有说明它的内容。 语义元素示例： &amp;lt;form&amp;gt;、&amp;lt;table&amp;gt;和&amp;lt;article&amp;gt;- 明确定义其内容。
HTML 中的语义元素 许多网站包含 HTML 代码，例如： 来指示导航、页眉和页脚。
在 HTML 中，有一些语义元素可用于定义网页的不同部分：</description>
    </item>
    
    <item>
      <title>HTML-Validation</title>
      <link>chick26.github.io/cards/-front-dev/html/html-validation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/html/html-validation/</guid>
      <description>up:: [ • TOC for Frontend
不同类型的表单数据校验 在 Web 中，你可能会遇见各种不同的表单校验：
客户端校验 发生在浏览器端，表单数据被提交到服务器之前，这种方式相较于服务器端校验来说，用户体验更好，它能实时的反馈用户的输入校验结果，这种类型的校验可以进一步细分成下面这些方式：
 JavaScript 校验，这是可以完全自定义的实现方式； HTML5 内置校验，这不需要 JavaScript ，而且性能更好，但是不能像JavaScript那样可自定义。  服务器端校验 发生在浏览器提交数据并被服务器端程序接收之后 —— 通常服务器端校验都是发生在将数据写入数据库之前，如果数据没通过校验，则会直接从服务器端返回错误消息，并且告诉浏览器端发生错误的具体位置和原因，服务器端校验不像客户端校验那样有好的用户体验，因为它直到整个表单都提交后才能返回错误信息。但是服务器端校验是你的应用对抗错误/恶意数据的最后防线，在这之后，数据将被持久化至数据库。当今 所有的服务端框架都提供了数据校验与清洁功能（让数据更安全）。</description>
    </item>
    
    <item>
      <title>HTML-Validation</title>
      <link>chick26.github.io/cards/-front-dev/html/html-validation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/html/html-validation/</guid>
      <description>up:: [ • TOC for Frontend
不同类型的表单数据校验 在 Web 中，你可能会遇见各种不同的表单校验：
客户端校验 发生在浏览器端，表单数据被提交到服务器之前，这种方式相较于服务器端校验来说，用户体验更好，它能实时的反馈用户的输入校验结果，这种类型的校验可以进一步细分成下面这些方式：
 JavaScript 校验，这是可以完全自定义的实现方式； HTML5 内置校验，这不需要 JavaScript ，而且性能更好，但是不能像JavaScript那样可自定义。  服务器端校验 发生在浏览器提交数据并被服务器端程序接收之后 —— 通常服务器端校验都是发生在将数据写入数据库之前，如果数据没通过校验，则会直接从服务器端返回错误消息，并且告诉浏览器端发生错误的具体位置和原因，服务器端校验不像客户端校验那样有好的用户体验，因为它直到整个表单都提交后才能返回错误信息。但是服务器端校验是你的应用对抗错误/恶意数据的最后防线，在这之后，数据将被持久化至数据库。当今 所有的服务端框架都提供了数据校验与清洁功能（让数据更安全）。</description>
    </item>
    
    <item>
      <title>HTTP</title>
      <link>chick26.github.io/cards/-front-dev/internet/http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/internet/http/</guid>
      <description>up:: [ • TOC for Frontend
 超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议, [[../../../..//Cards/📲%20Front%20Dev/Internet/HTTP.md]]是 [[WWW.md|万维网]] 的数据通信的基础。设计 [[../../../..//Cards/📲%20Front%20Dev/Internet/HTTP.md]] 最初的目的是为了提供一种发布和接收 [[../../../..//Cards/📲%20Front%20Dev/Internet/HTTP.md]] 页面的方法。通过 [[../../../..//Cards/📲%20Front%20Dev/Internet/HTTP.md]] 或者 [[../../../..//Cards/📲%20Front%20Dev/Internet/HTTP.md|HTTPS协议]] 请求的资源由 [[URL.</description>
    </item>
    
    <item>
      <title>Playwright Off-line Development</title>
      <link>chick26.github.io/cards/%EF%B8%8F-python/playwright-off-line-development/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/%EF%B8%8F-python/playwright-off-line-development/</guid>
      <description>up:: [ • TOC for Python
Off-line System Python Develop Environment Configuration Anaconda Off-line Package Installation  Download the wheel package.</description>
    </item>
    
    <item>
      <title>Playwright Off-line Development</title>
      <link>chick26.github.io/cards/%EF%B8%8F-python/playwright-off-line-development/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/%EF%B8%8F-python/playwright-off-line-development/</guid>
      <description>up:: [ • TOC for Python
Off-line System Python Develop Environment Configuration Anaconda Off-line Package Installation  Download the wheel package.</description>
    </item>
    
    <item>
      <title>Promise 常用方法</title>
      <link>chick26.github.io/cards/-front-dev/javascript/promise-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/javascript/promise-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>up:: [ • TOC for Frontend
Promise 中的三兄弟 .all(), .race(), .allSettled() 从 ES6 开始，我们大都使用的是 Promise.all()和Promise.race()，Promise.allSettled() 提案已经到第4阶段，因此将会成为ECMAScript 2020的一部分。
1. 概述 Promise.all&amp;lt;T&amp;gt;(promises: Iterable&amp;lt;Promise&amp;lt;T&amp;gt;&amp;gt;): Promise&amp;lt;Array&amp;lt;T&amp;gt;&amp;gt;</description>
    </item>
    
    <item>
      <title>Promise 常用方法</title>
      <link>chick26.github.io/cards/-front-dev/javascript/promise-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/javascript/promise-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>up:: [ • TOC for Frontend
Promise 中的三兄弟 .all(), .race(), .allSettled() 从 ES6 开始，我们大都使用的是 Promise.all()和Promise.race()，Promise.allSettled() 提案已经到第4阶段，因此将会成为ECMAScript 2020的一部分。
1. 概述 Promise.all&amp;lt;T&amp;gt;(promises: Iterable&amp;lt;Promise&amp;lt;T&amp;gt;&amp;gt;): Promise&amp;lt;Array&amp;lt;T&amp;gt;&amp;gt;</description>
    </item>
    
    <item>
      <title>rollup.js</title>
      <link>chick26.github.io/cards/-front-dev/package/rollup.js/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/package/rollup.js/</guid>
      <description>up:: [ • TOC for Frontend
 rollup.js 是一个 JavaScript 打包工具。本文介绍它的基本用法。
一、简介 打包工具的作用是，将多个 JavaScript 脚本合并成一个脚本，供浏览器使用。浏览器需要脚本打包，主要原因有三个。
（1）早期的浏览器不支持模块，大型网页项目只能先合并成单一脚本再执行。 （2）Node.js 的模块机制与浏览器不兼容，必须通过打包工具进行兼容处理。 （3）浏览器加载一个大脚本，要比加载多个小脚本，性能更好。
目前，最常用的打包工具是 Webpack。它的功能强大，但是难学难用，一直被人诟病。</description>
    </item>
    
    <item>
      <title>rollup.js</title>
      <link>chick26.github.io/cards/-front-dev/package/rollup.js/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/package/rollup.js/</guid>
      <description>up:: [ • TOC for Frontend
 rollup.js 是一个 JavaScript 打包工具。本文介绍它的基本用法。
一、简介 打包工具的作用是，将多个 JavaScript 脚本合并成一个脚本，供浏览器使用。浏览器需要脚本打包，主要原因有三个。
（1）早期的浏览器不支持模块，大型网页项目只能先合并成单一脚本再执行。 （2）Node.js 的模块机制与浏览器不兼容，必须通过打包工具进行兼容处理。 （3）浏览器加载一个大脚本，要比加载多个小脚本，性能更好。
目前，最常用的打包工具是 Webpack。它的功能强大，但是难学难用，一直被人诟病。</description>
    </item>
    
    <item>
      <title>Superset Local Develop</title>
      <link>chick26.github.io/cards/%EF%B8%8F-python/superset-local-develop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/%EF%B8%8F-python/superset-local-develop/</guid>
      <description>up:: [ • TOC for Python
Local Development  Prepare for develop environment  1 2 3 4 5 6 7 8 9 10 11  # Pull code from github git clone https://github.</description>
    </item>
    
    <item>
      <title>Superset Off-line Installation</title>
      <link>chick26.github.io/cards/%EF%B8%8F-python/superset-off-line-installation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/%EF%B8%8F-python/superset-off-line-installation/</guid>
      <description>up:: [ • TOC for Python
Version Checking  CentOS Version  1 2  cat /etc/redhat-release # CentOS Linux release 7.</description>
    </item>
    
    <item>
      <title>Superset Off-line Installation</title>
      <link>chick26.github.io/cards/%EF%B8%8F-python/superset-off-line-installation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/%EF%B8%8F-python/superset-off-line-installation/</guid>
      <description>up:: [ • TOC for Python
Version Checking  CentOS Version  1 2  cat /etc/redhat-release # CentOS Linux release 7.</description>
    </item>
    
    <item>
      <title>TypeScript 语法</title>
      <link>chick26.github.io/cards/-front-dev/typescript/typescript-%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/typescript/typescript-%E8%AF%AD%E6%B3%95/</guid>
      <description>up:: [ • TOC for Frontend
1. 简介 Javascript的超集，特点：扩展语法、面向对象、静态类型。
全局安装typescript 1  yarn global add typescript   编译执行TS文件 1 2  tsc demo.</description>
    </item>
    
    <item>
      <title>Web Browsers</title>
      <link>chick26.github.io/cards/-front-dev/internet/web-browsers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/internet/web-browsers/</guid>
      <description>up:: [ • TOC for Frontend
1. 浏览器高层结构  用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。 浏览器引擎 - 在用户界面和呈现引擎之间传送指令。 呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript 解释器。用于解析和执行 JavaScript 代码。 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库   2.</description>
    </item>
    
    <item>
      <title>Web Hosting</title>
      <link>chick26.github.io/cards/-front-dev/internet/web-hosting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/internet/web-hosting/</guid>
      <description>up:: [ • TOC for Frontend
 虚拟主机（英语：virtual hosting）或称 共享主机（shared web hosting），又称虚拟服务器，是一种在单一主机或主机群上，实现多网域服务的方法，可以执行多个网站或服务的技术。虚拟主机之间完全独立，并可由用户自行管理，虚拟并非指不存在，而是指空间是由实体的服务器延伸而来，其硬件系统可以是基于服务器群，或者单个服务器。
其技术是互联网服务器采用的节省服务器硬件成本的技术，虚拟主机技术主要应用于HTTP，FTP，EMAIL等多项服务，将一台服务器的某项或者全部服务内容逻辑划分为多个服务单位，对外表现为多个服务器，从而充分利用服务器硬件资源。如果划分是系统级别的，则称为虚拟服务器。
 使用虚拟服务器目的 方便管理 所有的虚拟主机都在同一部主机中，因此彼此可以共享相同的配置设置，借此节省管理的人力与成本。
提高性能 相同主机内的虚拟主机可以共享彼此的程序集（Process Pool），因此可以缩短对客户端的回应时间.</description>
    </item>
    
    <item>
      <title>前端技术应用方向</title>
      <link>chick26.github.io/sources/talks/%E9%98%BF%E9%87%8C%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%E7%94%9F/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8%E6%96%B9%E5%90%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/sources/talks/%E9%98%BF%E9%87%8C%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%E7%94%9F/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8%E6%96%B9%E5%90%91/</guid>
      <description>技术应用方向 互动技术  动画: cSS3 | SVG | Lottie | Canvas 3D: WebGL | oasis 3D | lottie-pixi WebXR: 结合 AR | VR  智能化   图像大厨 imgcook  Node.</description>
    </item>
    
    <item>
      <title>前端组件库设计</title>
      <link>chick26.github.io/cards/-front-dev/uilibrary/%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%BA%93%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/uilibrary/%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%BA%93%E8%AE%BE%E8%AE%A1/</guid>
      <description>up:: [ • TOC for Frontend
前端组件库的设计原则 细粒度的考量 设计模式: 单一职责原则，所谓的单一职责组件要建立在可复用的基础上，对于不可复用的单一职责组件我们仅仅作为独立组件的内部组件即可。
通用性考量 Antd 依赖了大量以rc-开头的底层组件, 这些组件由 react-component (同时也就是 Antd 团队) 维护, 其主要实现组件的底层逻辑, Antd 则是在此基础上添加 Ant Design 设计语言而实现的，以 Select 组件为例，基本将所有的 DOM 结构控制权全部暴露给了开发者,，其本身只负责底层逻辑和最基本的 DOM 结构.</description>
    </item>
    
    <item>
      <title>前端部署</title>
      <link>chick26.github.io/cards/-front-dev/package/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/package/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2/</guid>
      <description>up:: [ • TOC for Frontend
静态页面 先从简单的静态页面开始，众所周知，前端资源由 HTML、JavaScript、CSS 三剑客组成，假设我们有一个简单的页面，用 Nginx 作为 Web 服务器，资源组织结构大概如下：
HTML 1 2 3 4  &amp;lt;!</description>
    </item>
    
    <item>
      <title>前端部署</title>
      <link>chick26.github.io/cards/-front-dev/package/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/package/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2/</guid>
      <description>up:: [ • TOC for Frontend
静态页面 先从简单的静态页面开始，众所周知，前端资源由 HTML、JavaScript、CSS 三剑客组成，假设我们有一个简单的页面，用 Nginx 作为 Web 服务器，资源组织结构大概如下：
HTML 1 2 3 4  &amp;lt;!</description>
    </item>
    
    <item>
      <title>前端部署</title>
      <link>chick26.github.io/cards/-front-dev/package/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/package/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2/</guid>
      <description>up:: [ • TOC for Frontend
静态页面 先从简单的静态页面开始，众所周知，前端资源由 HTML、JavaScript、CSS 三剑客组成，假设我们有一个简单的页面，用 Nginx 作为 Web 服务器，资源组织结构大概如下：
HTML 1 2 3 4  &amp;lt;!</description>
    </item>
    
    <item>
      <title>浏览器解析 CSS 样式的过程</title>
      <link>chick26.github.io/cards/-front-dev/css/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90-css-%E6%A0%B7%E5%BC%8F%E7%9A%84%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/cards/-front-dev/css/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90-css-%E6%A0%B7%E5%BC%8F%E7%9A%84%E8%BF%87%E7%A8%8B/</guid>
      <description>up:: [ • TOC for Frontend
解析 一旦 CSS 被浏览器下载，CSS 解析器就会被打开来处理它遇到的任何 CSS。这可以是单个文档内的 CSS、&amp;lt;style&amp;gt;标记内的 CSS，也可以是 DOM 元素的style属性内嵌的 CSS。所 有 CSS 都根据语法规范进行解析和标记。解析完成后，就会生成有一个包含所有选择器、属性和属性各自值的数据结构。</description>
    </item>
    
  </channel>
</rss>
