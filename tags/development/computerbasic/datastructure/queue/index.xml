<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development/ComputerBasic/DataStructure/Queue on </title>
    <link>chick26.github.io/tags/development/computerbasic/datastructure/queue/</link>
    <description>Recent content in Development/ComputerBasic/DataStructure/Queue on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="chick26.github.io/tags/development/computerbasic/datastructure/queue/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Blocking queue</title>
      <link>chick26.github.io/sources/courses/%EF%B8%8F-algorithms/blocking-queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/sources/courses/%EF%B8%8F-algorithms/blocking-queue/</guid>
      <description>问题 阻塞队列其实就是在 [[Queue.md|队列]] 基础上增加了阻塞操作。简单来说，就是
 在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回； 如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。  使用阻塞队列，就可以轻松实现一个 生产者 - 消费者模型 这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。可以多配置几个“消费者”，来应对一个“生产者”
![ Blocking queue.excalidraw|800
实现 Python 基于阻塞队列实现的生产者 - 消费者模型：</description>
    </item>
    
    <item>
      <title>Concurrent queue</title>
      <link>chick26.github.io/sources/courses/%EF%B8%8F-algorithms/concurrent-queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/sources/courses/%EF%B8%8F-algorithms/concurrent-queue/</guid>
      <description>在多线程情况下，会有多个线程同时操作 [[Queue.md|队列]]，这个时候就会存在线程安全问题。线程安全的队列叫作并发队列。最简单直接的实现方式是直接在 enqueue ()、dequeue () 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</description>
    </item>
    
    <item>
      <title>Finite resource pool</title>
      <link>chick26.github.io/sources/courses/%EF%B8%8F-algorithms/finite-resource-pool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/sources/courses/%EF%B8%8F-algorithms/finite-resource-pool/</guid>
      <description>常见的有限资源池有线程池和数据库连接池。 CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。 当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？ 线程池一般有两种处理策略：
 非阻塞的处理方式，直接拒绝任务请求； 阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。  我们希望公平地处理每个排队的请求，先进者先服务，[[Queue.md|队列]] 这种数据结构很适合来存储排队请求。基于链表实现的队列，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。队列设置太大会导致等待的请求太多，设置太小会导致无法充分利用系统资源、发挥最大性能。 对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</description>
    </item>
    
    <item>
      <title>Queue</title>
      <link>chick26.github.io/sources/courses/%EF%B8%8F-algorithms/queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>chick26.github.io/sources/courses/%EF%B8%8F-algorithms/queue/</guid>
      <description>up:: [ • TOC for Algorithm Course
1 基本结构  [!Example]- 操作受限，先进先出 循环队列、阻塞队列、并发队列等具有某些额外特性的队列，它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列； Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。</description>
    </item>
    
  </channel>
</rss>
