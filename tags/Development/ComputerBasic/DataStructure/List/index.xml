<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Development/ComputerBasic/DataStructure/List on</title><link>chick26.github.io/tags/Development/ComputerBasic/DataStructure/List/</link><description>Recent content in Development/ComputerBasic/DataStructure/List on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="chick26.github.io/tags/Development/ComputerBasic/DataStructure/List/index.xml" rel="self" type="application/rss+xml"/><item><title>Josephus Problem Using List</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Josephus-Problem-Using-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Josephus-Problem-Using-List/</guid><description>问题 有 n 个人围成一圈，顺序排号。从第一个人开始报数（从 1 到 m 报数），凡报到 m 的人退出圈子，直到船上仅剩 r 人为止, 问都有哪些编号的人下船了呢？
实现 假设 n=30，m=9，r=15 [[Array.md|数组]] 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 # -*- coding: utf-8 -*- __author__ = &amp;#39;xiaoxiaoming&amp;#39; n, m, r = 30, 9, 15 circle = list(range(1, n + 1)) # index+1代表当前报数的人在剩余报数人群中的编号 index = 0 result = [] while len(circle) &amp;gt; r: index += m-1 if (index &amp;gt;= len(circle)): index -= len(circle) result.</description></item><item><title>List</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/List/</guid><description>up:: [ • TOC for Algorithm Course
1 基本结构 ![[../../../Extras/Excalidraw/算法之美/list-construct.excalidraw.md|600]]
1.1 单链表 上图中有两个特殊的结点，分别是第一个结点（头结点）和最后一个结点（尾结点）。 头结点用来记录链表的基地址，用它可以遍历得到整条链表。 尾结点指向一个空地址 NULL，表示这是链表上最后一个结点。 1.2 循环链表 和单链表相比，循环链表的优点是从链尾到链头比较方便。 当要处理的数据具有环型结构特点时，采用循环链表实现代码会简洁很多。 1.</description></item><item><title>LRU Using List</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/LRU-Using-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/LRU-Using-List/</guid><description>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。
[!INFO]- 缓存淘汰策略
先进先出策略 FIFO（First In，First Out） 最少使用策略 LFU（Least Frequently Used） 最近最少使用策略 LRU（Least Recently Used） LRU 缓存的实现 思路：维护一个[[List.</description></item><item><title>Palindromic string</title><link>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Palindromic-string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>chick26.github.io/Sources/Courses/%EF%B8%8F-Algorithms/Palindromic-string/</guid><description>问题 如果字符串是通过 [[List.md| 单链表]] 来存储的，那该如何来判断是一个回文串呢？
思路 使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。这样当快指针指向末尾时，慢指针指向了中点。 在慢指针前进的过程中，同时修改其 next 指针指向上一个元素 prev，使得链表前半部分反序。 最后比较中点两侧的链表是否相等。 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class ListNode(object): def __init__(self, val, next=None): self.</description></item></channel></rss>